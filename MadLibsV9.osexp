---
API: 2.1
OpenSesame: 3.2.5
Platform: nt
---
set width 1920
set uniform_coordinates yes
set transparent_variables no
set title "Attend-and-click training"
set synth_backend legacy
set subject_parity even
set subject_nr 0
set start experiment
set sound_sample_size -16
set sound_freq 48000
set sound_channels 2
set sound_buf_size 1024
set sampler_backend legacy
set round_decimals 2
set mouse_backend psycho
set keyboard_backend psycho
set height 1080
set fullscreen no
set form_clicks no
set foreground white
set font_underline no
set font_size 18
set font_italic no
set font_family mono
set font_bold no
set experiment_path "E:\\User-Models-Project"
set disable_garbage_collection yes
set description "A brain-computer interface based on covert attention and pupillometry"
set coordinates relative
set compensation 0
set color_backend psycho
set clock_backend psycho
set canvas_backend psycho
set bidi no
set background "#4c4c4c"

define notepad README
	__note__
	This experiment implements a pupillometry-based human-computer interface, as
	described in:
		
		Mathôt, Melmi, van der Linden, & Van der Stigchel (2016). A human-computer
		interface based on decoding of covert visual attention through pupillometry.
		PLoS ONE.
	__end__
	set description "A simple notepad to document your experiment. This plug-in does nothing."

define pygaze_start_recording _pygaze_start_recording
	set status_msg "start_trial [count_free_writing]"
	set description "Puts the eye tracker into recording mode"

define sketchpad blank
	set reset_variables no
	set duration 0
	set description "Displays stimuli"

define loop calibration
	set source_file ""
	set source table
	set repeat 1
	set order sequential
	set description "Repeatedly runs another item"
	set cycles 1
	set continuous no
	set break_if_on_first yes
	set break_if never
	setcycle 0 empty_column 0
	run calibration_sequence

define sequence calibration_sequence
	set flush_keyboard yes
	set description "Runs a number of items in sequence"
	run pygaze_drift_correct always
	run pygaze_start_recording_2 always
	run new_inline_script always
	run pygaze_stop_recording always

define inline_script default_settings
	set description "Executes Python code"
	set _run ""
	___prepare__
	var.mode2 = '90upmirror'
	var.ecc = 390
	var.size = 132
	var.showCue = 'no'
	__end__

define loop eight_options
	set source_file ""
	set source table
	set skip 0
	set repeat 2
	set order random
	set offset no
	set item exp_sequence
	set description "Repeatedly runs another item"
	set cycles 2
	set continuous no
	set column_order "target;itemIds"
	set break_if_on_first yes
	set break_if never
	setcycle 0 colorDown black
	setcycle 0 colorLeft black
	setcycle 0 colorRight black
	setcycle 0 colorUp black
	setcycle 0 rowNumber 1
	setcycle 1 colorDown white
	setcycle 1 colorLeft white
	setcycle 1 colorRight white
	setcycle 1 colorUp white
	setcycle 1 rowNumber 2
	run exp_sequence

define sequence exp_sequence
	set flush_keyboard yes
	set description "Runs a number of items in sequence"
	run pygaze_drift_correct always
	run pygaze_start_recording always
	run speak_target always
	run select_target always
	run feedback always
	run blank always
	run pygaze_log always
	run logger always
	run pygaze_stop_recording always

define sequence experiment
	set flush_keyboard yes
	set description "Runs a number of items in sequence"
	run README always
	run pygaze_init always
	run form_base never
	run python_definitions always
	run eight_options never
	run calibration always
	run four_options always
	run free_writing_loop "[free_writing] = yes"
	run final_feedback "[free_writing] != yes"
	run keyboard_response always

define inline_script eye_tracker
	set description "Eye-tracker functionality"
	___run__
	if 'dummy' in exp.items['pygaze_init'].tracker_type:
		pylink = None
	else:
		import pylink
	
	def collectPupilTrace(itemArray, dur, fd=10):
		
		"""
		desc:
			Returns an array of recorded pupil-size values.
			
		arguments:
			itemArray:		An ItemArray object.
			dur:			The recording duration.
			fd:				The frame duration in milliseconds.
			
		returns:
			A numpy array that with a dur/fd length.
		"""
		
		t0 = self.time()
		a = np.zeros(dur/fd)
		_dt = 0
		while _dt < dur:		
			itemArray.show()
			if pylink != None:
				ps = eyetracker.pupil_size()
			else:
				# Use Y coordinate of mouse
				ps = my_mouse.get_pos()[0][1]+var.height/2
			dt = self.time()-t0
			a[int(_dt/fd):int(dt/fd)] = ps
			_dt = dt
			if my_keyboard.get_key()[0] == 'space':
				say(var.target)
		return a
	__end__
	set _prepare ""

define feedback feedback
	set reset_variables no
	set duration keypress
	set description "Provides feedback to the participant"
	draw textline center=1 color=green font_bold=no font_family=sans font_italic=no font_size=32 html=yes show_if=always text="<b>End of selection</b><br /><br />Correct: [var.winner]<br />Duration: [loop_rt] s<br /><br />Press a key to continue ..." x=0 y=0 z_index=0

define feedback final_feedback
	set reset_variables yes
	set duration 0
	set description "Provides feedback to the participant"
	draw textline center=1 color=green font_bold=no font_family=sans font_italic=no font_size=32 html=yes show_if=always text="<b>Fin du bloc</b><br /><br />Précision: [acc] %<br />Temps de réponse moyenne: [avg_rt] s<br /><br />Vuillez appeler l'experimentateur" x=0 y=0 z_index=0
	draw textline center=1 color=green font_bold=no font_family=sans font_italic=no font_size=18 html=yes show_if=always text="Appuyez 'q' pour quitter." x=0 y=448 z_index=0

define form_base form_base
	set timeout infinite
	set spacing 10
	set rows "2;3;3;1;1"
	set only_render no
	set margins "20;20;20;20"
	set description "A generic form plug-in"
	set cols "1;1"
	set _theme gray
	widget 0 0 2 1 image path="getyourmindwrite.png"
	widget 0 1 1 1 image_button path="2afc.png" var=opt2
	widget 1 1 1 1 image_button path="4afc.png" var=opt4
	widget 0 2 1 1 image_button path="8afc.png" var=opt8
	widget 1 2 1 1 image_button path="freewriting.png" var=free_writing
	widget 0 3 1 1 checkbox text="Check fixation / Controle de fixation" var=checkFix
	widget 1 3 1 1 checkbox text="Gaze stabilization / Stabilisation de regard" var=stabilize
	widget 0 4 1 1 label text="Threshold/ Seuil"
	widget 1 4 1 1 text_input text=1.375 var=likelihoodThr


define form_base form_base_1
	set timeout infinite
	set spacing 10
	set rows "2;3;3;1;1"
	set only_render no
	set margins "50;50;50;50"
	set description "A generic form plug-in"
	set cols "1;1"
	set _theme gray
	widget 0 0 2 1 image path="getyourmindwrite.png"
	widget 0 1 1 1 image_button path="2afc.png" var=opt2
	widget 1 1 1 1 image_button path="4afc.png" var=opt4
	widget 0 2 1 1 image_button path="8afc.png" var=opt8
	widget 1 2 1 1 image_button path="freewriting.png" var=free_writing
	widget 0 3 1 1 checkbox text="Check fixation / Controle de fixation" var=checkFix
	widget 1 3 1 1 checkbox text="Gaze stabilization / Stabilisation de regard" var=stabilize
	widget 0 4 1 1 label text="Threshold/ Seuil"
	widget 1 4 1 1 text_input text=1.375 var=likelihoodThr


define loop four_options
	set source_file ""
	set source table
	set skip 0
	set repeat 4
	set order random
	set offset no
	set item exp_sequence
	set description "Repeatedly runs another item"
	set cycles 4
	set continuous no
	set column_order "target;itemIds"
	set break_if_on_first yes
	set break_if never
	setcycle 0 target A
	setcycle 0 itemIds ABCD
	setcycle 1 target B
	setcycle 1 itemIds ABCD
	setcycle 2 target C
	setcycle 2 itemIds ABCD
	setcycle 3 target D
	setcycle 3 itemIds ABCD
	run exp_sequence

define sequence free_writing
	set flush_keyboard yes
	set description "Runs a number of items in sequence"
	run pygaze_drift_correct always
	run _pygaze_start_recording always
	run free_writing_script always
	run free_writing_feedback always
	run pygaze_log always
	run logger always
	run pygaze_stop_recording always

define feedback free_writing_feedback
	set reset_variables no
	set duration keypress
	set description "Provides feedback to the participant"
	draw textline center=1 color=white font_bold=no font_family=sans font_italic=no font_size=32 html=yes show_if=always text="You wrote:<br /><br />[free_writing_text]<br />" x=0 y=0 z_index=0
	draw textline center=1 color=white font_bold=no font_family=sans font_italic=no font_size=18 html=yes show_if=always text="Appuyez sur 'q' pour quitter." x=0 y=448 z_index=0

define loop free_writing_loop
	set source_file ""
	set source table
	set skip 0
	set repeat 1
	set order random
	set offset no
	set item free_writing
	set description "Repeatedly runs another item"
	set cycles 1
	set continuous no
	set column_order ""
	set break_if_on_first yes
	set break_if never
	setcycle 0 empty_column ""
	run free_writing

define inline_script free_writing_script
	set description "Executes Python code"
	___run__
	s = ''
	t0 = clock.time()
	eyetracker.log('start_free_writing')
	while True:
		ch = getInput(writingIndicator=s)
		if ch == 'Finish':
			break
		if ch == 'Del' and len(s) > 0:
			s = s[:-1]
		elif ch == 'Space':
			s += u' '
		else:
			s += ch
		say(s)
	t1 = clock.time()
	say('You wrote %s' % s)
	var.free_writing_text = s
	eyetracker.log('var free_writing_result %s' % s)
	eyetracker.log('var free_writing_time %s' % (t1-t0))
	eyetracker.log('end_free_writing')
	__end__
	set _prepare ""

define inline_script get_input
	set description "Executes Python code"
	___run__
	def getInput(writingIndicator=None):
		
		"""
		desc:
			Gets a single input character.
			
		keywords:
			writingIndicator:	See ItemArray.
			
		returns:
			An input character
		"""
	
		exp.pygaze_eyetracker.log('start_get_input')
		items = {
			'1'			: ['1'],
			'2'			: ['2'],
			'3'			: ['3'],
			'4'			: ['4'],
			}
		itemKeys = [
			'1',
			'2',
			'3',
			'4',
			]
		if self.get('stabilize') != 'no':
			stabilize = True
		else:
			stabilize = False		
		if self.get('checkFix') != 'no':
			checkFix = True
		else:
			checkFix = False
		ia = ItemArray(itemKeys,
			ecc=self.get('ecc'),
			size=self.get('size'),
			bgScale=2,
			stabilize=stabilize,
			writingIndicator=writingIndicator,
			check=checkFix
			)
		var.winner = ia.selectionLoop(
			target=None,
			mode2=self.get('mode2'),
			likelihoodThr=self.get('likelihoodThr'),
			cue=False
			)
		print 'Winner of first round %s' % var.winner
		exp.pygaze_eyetracker.log('end_get_input %s' % var.winner)
		return var.winner
	__end__
	set _prepare ""

define inline_script globals
	set description "Global objects and import statements"
	___run__
	import string
	import numpy as np
	import random
	import os
	from psychopy.visual import TextStim, GratingStim, ImageStim
	import subprocess
	import difflib
	
	my_keyboard = keyboard(timeout=0)
	my_mouse = mouse()
	xc = var.width/2
	yc = var.height/2
	
	
	var.topRightPattern =    [-1,0,1,0,1] 	#B G W G W
	var.topLeftPattern =     [1,-1,0,-1,0]  #W B G B G 
	var.bottomLeftPattern =  [0,1,-1,0,-1]  #G W B G B
	var.bottomRightPattern = [-1,0,-1,1,0]  #B G B W G
	var.threshold = 1
	
	var.numberOfColors =5
	var.predictionArray = np.zeros(var.numberOfColors)
	
	var.words = ["milk","showergel","force","lube"]
	
	var.compareArray = [ var.topLeftPattern, var.bottomRightPattern, var.topRightPattern, var.bottomLeftPattern]
	var.similarityMatrix = []
	
	var.winnerCount = np.zeros(4)
	
	var.prevWordProbability = np.zeros(4)
	var.currWordProbability = np.zeros(4)
	
	
	#Calibration settings
	import random
	import string
	import sys
	from time import sleep
	var.stop= False
	var.counter=0
	var.colorInterval=100
	
	var.minWhiteThreshold= 0
	var.maxWhiteThrehold= 0
	var.minBlackThreshold= 0
	var.maxBlackThreshold = 0
	
	var.firstCycle = True
	var.firstPattern= True
	
	var.bgScale =2.65
	__end__
	set _prepare ""

define inline_script item
	set description "Class definition"
	___run__
	class Item(object):
		
		"""
		desc:
			A single selectable item.
		"""
		
		def __init__(self, itemArray, itemId, angle, ecc, opacity=.5, color='green',
			size=64, brightness=1, mirror=False, bgScale= var.bgScale):
				
			"""
			desc:
				constructor.
				
			arguments:
				itemArray:		An ItemArray object.
				itemId:			A string that is shown and identifies the item.
				angle:			
								The angular position of the item. This is in radians
								counterclockwise, starting from a 3 o'clock
								position.
				ecc:			The eccentricity of the item.
			
			keywords:
				opacity:		The opacity of the item-id string.
				color:			The color of the item-id string.
				size:			
								The size of the item, which corresponds to the
								height of the item-id string and the radius of the
								background patch.
				brightness:		The brightness of the background patch.			
				mirror:			Indicates whether a 'mirror' background patch
								should be shown as well.
				bgScale:		The size of the background relative to the
								items.
			"""
			
			self.itemArray = itemArray
			self.itemId = itemId
			self.opacity = .5
			self.color = color
			self.size = size
			self.lLikelihood = [1]
			self.angle = angle
			self.imScale = 1.5
			self.brightness = brightness
			self.ecc = ecc
			self.background = GratingStim(win, tex=None, mask='raisedCos',
				color=self.brightness, size=size*bgScale)
			self.showMirror = mirror
			self.mirror = GratingStim(win, tex=None, mask='raisedCos',
				color=self.brightness, size=size*bgScale)		
			path = os.path.join(exp.experiment_path, '__pool__', '%s.png' % itemId)
			if os.path.exists(path):
				self.stim = ImageStim(win, path, opacity=self.opacity)		
			else:
				self.stim = TextStim(win, itemId, opacity=self.opacity,
					color=self.color, height=size)		
			self.cue = GratingStim(win, tex=None, mask=None, color='green',
				size=(128,2))
			self.lPrediction = []
			self.lPupilSize = []
			self.setAngle(angle)
										
		def likelihood(self):
			
			"""
			desc:
				Determines the most recent likelihood estimate that this item is
				selected.
				
			returns:
				A likelihood value.
			"""
			
			if np.isnan(self.lLikelihood[-1]):
				return 1
			return self.lLikelihood[-1]
			
		def setBrightness(self, brightness):
			
			"""
			desc:
				Sets the brightness of the background patch.
				
			arguments:
				brightness:		A brightness value.
			"""
			
			self.background.setColor(brightness)
			self.brightness = brightness
			self.mirror.setColor(brightness)
			
		def setAngle(self, angle):
			
			"""
			desc:
				Sets the angle of the item.
				
			arguments:
				angle:		The new angle.
			"""
			
			self.angle = angle
			x = self.ecc * np.cos(angle)
			y = self.ecc * np.sin(angle)
			self.xy = x,y
			self.stim.pos = self.xy
			self.background.pos = self.xy
			self.mirror.pos = -x, -y
			self.cue.setOri(np.degrees(-angle))
			
		def setPupilSize(self, pupilSize):
			
			"""
			desc:
				Sets the most recently recorded pupil size, and estimate a new
				likelihood value.
				
			arguments:
				pupilSize:		A pupil-size value.
			"""
			
			self.lPrediction.append(self.brightness)
			self.lPupilSize.append(pupilSize)
			if len(self.lPupilSize) > 1:
				pupilSizeChange = 1. * self.lPupilSize[-1] / self.lPupilSize[-2]
				if self.lPrediction[-1] == 1 and self.lPrediction[-2] == -1:
					likelihood = self.lLikelihood[-1] / pupilSizeChange
				elif self.lPrediction[-1] == -1 and self.lPrediction[-2] == 1:
					likelihood = self.lLikelihood[-1] * pupilSizeChange
				else:
					likelihood = self.lLikelihood[-1]
				self.lLikelihood.append(likelihood)
				
		def setXY(self, xy):
			
			"""
			desc:
				Sets the position of the item.
				
			arguments:
				xy:		An xy coordinate tuple.
			"""
			
			self.xy = xy
			self.stim.pos = xy
			self.background.pos = xy
			self.mirror.pos = -xy[0], -xy[1]
			
		def show(self, background=True, gazePos=None, cue=False):
			
			"""
			desc:
				Shows the item.
				
			keywords:
				background:		Indicates whether background patch should be shown
								as well.
				gazePos:		An (x,y) tuple with the most recent gaze position,
								used to perform retinal stabilization.
				cue:			Indicates whether a cue should be shown.
			"""
	
			if gazePos != None:
				gx, gy = gazePos
				gx -= xc
				gy -= yc
				self.background.setPos( (self.xy[0]+gx, self.xy[1]-gy) )
				self.mirror.setPos( (-self.xy[0]+gx, -self.xy[1]-gy) )
			if background:
				self.background.draw()
				if self.showMirror:
					self.mirror.draw()
			if cue:
				self.cue.draw()
			if hasattr(self.stim, 'setHeight'):
				try:
					self.stim.setHeight(int(self.size*2))
					#self.stim.setHeight(
					#	int(self.size*self.likelihood()/self.itemArray.meanLikelihood()))
				except:
					pass
			else:
				try:
					self.stim.setSize(
						int(self.imScale*self.size*self.likelihood()/self.itemArray.meanLikelihood()))
				except:
					pass
			self.stim.draw()
			
		def focus(self, steps=50):
			
			"""
			desc:
				Moves the item to the display center, indicating that it has been
				selected.
				
			keywords:
				steps:		The number of steps of the animation.
			"""
			
			x = np.linspace(self.xy[0], 0, steps)
			y = np.linspace(self.xy[1], 0, steps)		
			for i in range(steps):
				self.background.pos = x[i],y[i]
				self.stim.pos = x[i],y[i]
				self.mirror.pos = -x[i],-y[i]
				self.show()
				win.flip()
				
		def log(self, status='normal'):
			
			"""
			desc:
				Logs the item information.
				
			keywords:
				status:		The status of the item.
			"""
					
			exp.pygaze_eyetracker.log((u'item id="%s" status=%s likelihood=%s ecc=%s angle=%s '
				u'size=%s brightness=%s color=%s opacity=%s x=%s y=%s') % (
				self.itemId, status, self.likelihood(), self.ecc, self.angle,
				self.size, self.brightness, self.color, self.opacity, self.xy[0],
				self.xy[1]))
	__end__
	set _prepare ""

define inline_script itemArray
	set description "Class definition"
	___run__
	class ItemArray(object):
		
		"""
		desc:
			An array of selectable items.
		"""
	
		var.itemChange=[]
		def __init__(self, itemIds, stabilize=False, check=True, ecc=310, size=64,
			debug=True, bgScale= var.bgScale, writingIndicator=None):
			
			"""
			desc:
				Constructor.
				
			arguments:
				itemIds:	A list of item-id strings. There should be an even
							number of elements.
			
			keywords:
				stabilize:	Indicates whether retinal stabilization should be
							enabled.
				check:		Indicates whether the trial should be paused when
							fixation is lost.
				ecc:		The items' eccentricity.
				size:		The items' size.
				debug:		Indicates whether debugging info should be shown.
				bgScale:	See item.
				writingIndicator:
							Indicates whether an indicator of the free-written
							text should be shown.
			"""
			
		
			self.items = []
			self.stabilize = stabilize
			self.check = check
			self.ecc = ecc
			self.size = size		
			self.debug = debug
			brightness = random.choice([1,-1])
			if len(itemIds) == 4:
				angle = -.25*np.pi
			else:
				angle = 0
			for itemId in itemIds:			
				self.items.append(Item(self, itemId=itemId, angle=angle,
					ecc=ecc, brightness=brightness, size=size, bgScale=bgScale))
				brightness *= -1
				angle += 2*np.pi/len(itemIds)
			self.fixDot = GratingStim(win, tex=None, mask='circle', color='green',
				size=8)
			self.pupilSizeIndicator = TextStim(win, '-', pos=(xc-50, yc-20),
				color='black')
			if writingIndicator not in [None, '']:
				self.writingIndicator = TextStim(win, '"%s"' % writingIndicator,
					pos=(0, 20), color='green')
			else:
				self.writingIndicator = None
			self.pause = TextStim(win, 'Fixation lost')
				
		def show(self, background=True, cue=None):
			
			"""
			desc:
				Shows the ItemArray.
				
			keywords:
				background:		Indicates whether the backgrounds of the items
								should be shown as well.
				cue:			Indicates the item that should be cued, or None.
			"""
					
			if self.check:
				nErr = 0
				while True:
					gx, gy = eyetracker.sample()				
					gx -= xc
					gy -= yc
					err = np.sqrt(gx**2+gy**2)
					if err <= 100:
						break
					nErr += 1
					if nErr > 10:
						eyetracker.log('pause fixation_lost')
						self.pause.draw()
						win.flip()
						my_keyboard.flush()					
			if self.stabilize:
				gazePos = gx+xc, gy+yc
			else:
				gazePos = None
			for item in self.items:			
				if item.itemId == cue:
					showCue = True
				else:
					showCue = False
				item.show(background=background, gazePos=gazePos, cue=showCue)
			self.fixDot.draw()
			if self.debug:
				self.pupilSizeIndicator.draw()
			if self.writingIndicator != None:
				self.writingIndicator.draw()
			win.flip()
			
		def meanLikelihood(self):
			
			"""
			returns:
				The mean likelihood of all items.
			"""
			
			return np.mean([item.likelihood() for item in self.items])
		
		# Return the similarity percentage for each cycle - pattern and reading. 
		def comparePatterns(self, predictionArray):
			sm = np.zeros(4) 
			for i in range(0,4):
				sm[i] = np.mean(np.array(predictionArray) == np.array(var.compareArray[i]))
			print("sm",sm)
			return sm
		
		def chosenWord(self, sm):
			print("sm", sm)
			x, y = np.unique(sm, return_counts = True)
			if y[-1]==1 and max(sm)!= 0:
				bestWord = sm.argmax()
				var.winnerCount[bestWord] = var.winnerCount[bestWord] + 1
				print("winnerCount", var.winnerCount)
				var.currWordProbability = var.winnerCount/sum(var.winnerCount)
			else:
				return -1
				
			#Compare previous and current probs
			ascUniqueElements, ascFrequencyCount = np.unique(var.currWordProbability, return_counts = True)
			prevMaxIndex = var.prevWordProbability.argmax()
			currMaxIndex = var.currWordProbability.argmax()
			print("wordProbability", var.currWordProbability)
			
			print("acsUniqueElements", ascUniqueElements)
			print("ascFrequencyCount", ascFrequencyCount)
			
			#IF IT IS NOT THE FIRST CYCLE
			if var.firstPattern != True:
				# IF THE MAXIMUM VALUE APPEARS ONLY ONCE
				if ascFrequencyCount[-1] == 1:
					#IF THE PREVIOUS WINNER IS EQUAL TO THE CURRENT WINNER
					if prevMaxIndex == currMaxIndex:
			#			
						if abs(var.prevWordProbability[prevMaxIndex] - var.currWordProbability[currMaxIndex]) <= 0.2: 
							var.prevWordProbability = var.currWordProbability
							print("Previous Word Probability1", var.prevWordProbability)
							print("Current Word Probability1", var.currWordProbability)
							return currMaxIndex
						else:
							var.prevWordProbability = var.currWordProbability
							print("Previous Word Probability2", var.prevWordProbability)
							print("Current Word Probability2", var.currWordProbability)
							return -1
					else: 
						var.prevWordProbability = var.currWordProbability
						return -1
				else:		
					print("Made it")
					var.prevWordProbability = var.currWordProbability
					print("Previous Word Probability3", var.prevWordProbability)
					print("Current Word Probability3", var.currWordProbability)
					return -1
			#IF IT IS THE FIRST CYCLE, ASSIGN THE CURRENT PROBABILITIES TO THE PREVIOUS AND GO TO NEXT CYCLE
			else:
				var.prevWordProbability = var.currWordProbability
				var.firstPattern = False
				return -1
			
		# Comparing the meanPupilSize with the black and white thresholds.
		# If White set to 1, Black set to -1, else 0. 
		def getColor(self,index, meanPupilSize):
			if var.maxWhiteThreshold > meanPupilSize: 
				var.predictionArray[index] = 1
			elif meanPupilSize > var.minBlackThreshold: 
				var.predictionArray[index] = -1
			elif meanPupilSize >= var.maxWhiteThreshold and meanPupilSize <= var.minBlackThreshold:
				var.predictionArray[index] = 0
		
		def invert(self, dur=1500):
				#self.comparePatterns()	
				"""
				desc:
					Inverts the brightness of all items.
					
				keywords:
					steps:	The duration of the inversion animation.
				"""
				
				
				leftSideBottom = []
				leftSideTop = []
				leftSideTop.append(self.items[2])
				leftSideBottom.append(self.items[3])
				
				rightSideTop = []
				rightSideBottom = []
				rightSideTop.append(self.items[1])
				rightSideBottom.append(self.items[0])
				f = np.linspace(0, 1, dur/2)
				pupilSizeTraces = []
	
				# Iterate through each color in the defined global variables 
				for x in range(0,var.numberOfColors):
					t0 = exp.time()
					print('t0 ',t0)
					i = 0
					
					#set the color equal to the corresponding color of x in the global variable
					while i < dur/2:		
						if var.firstCycle == True:
							rightSideTop[0].setBrightness(var.topRightPattern[x])
							rightSideBottom[0].setBrightness(var.bottomRightPattern[x])
							leftSideTop[0].setBrightness(var.topLeftPattern[x])
							leftSideBottom[0].setBrightness(var.bottomLeftPattern[x])
							var.firstCycle = False
						else: 
							if var.topRightPattern[x-1] == var.topRightPattern[x]:
								rightSideTop[0].setBrightness(var.topRightPattern[x])
							else: 
								rightSideTop[0].setBrightness(var.topRightPattern[x] * f[i])
								
							if var.bottomRightPattern[x-1] == var.bottomRightPattern[x]:
								rightSideBottom[0].setBrightness(var.bottomRightPattern[x])
							else: 
								rightSideBottom[0].setBrightness(var.bottomRightPattern[x]* f[i])
								
							if var.topLeftPattern[x-1] == var.topLeftPattern[x]:
								leftSideTop[0].setBrightness(var.topLeftPattern[x])
							else:
								leftSideTop[0].setBrightness(var.topLeftPattern[x]* f[i])
								
							if var.bottomLeftPattern[x-1] == var.bottomLeftPattern[x]:
								leftSideBottom[0].setBrightness(var.bottomLeftPattern[x])
							else:
								leftSideBottom[0].setBrightness(var.bottomLeftPattern[x]* f[i])
						self.show()
						#print 'i = %s' % i
						t1 = exp.time()
						i = int(t1-t0)
					
					print('t1', t1)
					#eyetracker.log('start_round %d' % rounds)			
					eyetracker.log('start_invert')
					eyetracker.log('end_invert')
					eyetracker.log('start_adaptation')
					collectPupilTrace(self, dur)
					eyetracker.log('end_adaptation')
					eyetracker.log('start_collection')
					a = collectPupilTrace(self, dur/2)
					eyetracker.log('end_collection')
					meanPupilSize = np.median(a)
					self.getColor(x, meanPupilSize)
					self.pupilSizeIndicator.setText(str(meanPupilSize))
					for item in self.items:
						item.setPupilSize(meanPupilSize)	
					self.show()
				sm = self.comparePatterns(var.predictionArray)
				print("predictionArray", var.predictionArray)
				print("sm", sm)
				chosenOne = self.chosenWord(sm)
				return chosenOne
				
		def invertCalibration(self, dur, colour):
				#self.comparePatterns()	
				"""
				desc:
					Inverts the brightness of all items.
					
				keywords:
					steps:	The duration of the inversion animation.
				"""
				leftSideBottom = []
				leftSideTop = []
				#leftSideTop.append(self.items[2])
				#leftSideBottom.append(self.items[3])
				
				rightSideTop = []
				rightSideBottom = []
				#rightSideTop.append(self.items[1])
				rightSideBottom.append(self.items[0])
				#f = np.linspace(1, -1, dur)
				pupilSizeTraces = []
				i = 0
				# Iterate through each color in the defined global variables 
				t0 = exp.time()
				while i < dur:	
					for item in self.items:
						#leftSideTop[0].setBrightness(colour*(-1))
						rightSideBottom[0].setBrightness(colour)
						
						#rightSideTop[0].setBrightness(colour)
						#leftSideBottom[0].setBrightness(colour)
						#set the color equal to the corresponding color of x in the global variable#		
						#item.setBrightness(colour)
					self.show()
					t1 = exp.time()
					i = int(t1-t0)
			
				#eyetracker.log('start_round %d' % rounds)			
				eyetracker.log('start_invert')
				eyetracker.log('end_invert')
				eyetracker.log('start_adaptation')
				collectPupilTrace(self, dur)
				eyetracker.log('end_adaptation')
				eyetracker.log('start_collection')
				a = collectPupilTrace(self, dur/2)
				
				eyetracker.log('end_collection')
				meanPupilSize = np.median(a)
				if colour == 1:
					var.minWhiteThreshold = meanPupilSize*0.88
					print("minWhiteThreshold", var.minWhiteThreshold)
					var.maxWhiteThreshold = meanPupilSize*1.12
					print("maxWhiteThreshold", var.maxWhiteThreshold)
				else:
					var.minBlackThreshold = meanPupilSize*0.88
					print("minBlackThreshold", var.minBlackThreshold)
					var.maxBlackThreshold = meanPupilSize*1.12
					print("maxBlackThreshold", var.maxBlackThreshold)
				self.pupilSizeIndicator.setText(str(meanPupilSize))
				for item in self.items:
					item.setPupilSize(meanPupilSize)	
				self.show()
				
				
		def setMode2(self, mode2, steps=50):
			
			"""
			desc:
	
				See mode2 description in __init__().
				
			arguments:
				mode2:	See __init__().
			"""
			
			mode2 = str(mode2)
			assert(mode2 in ['180', '90up', '90down', '90upmirror', '90downmirror'])
			if len(self.items) != 2 or mode2 == '180':
				return
			if '90down' in mode2:
				# If item 0 is closer to the -.25pi angle than item 1
				if np.abs(self.items[0].angle+.25*np.pi) < \
					np.abs(self.items[1].angle+.25*np.pi):			
					a0 = -.25 * np.pi
					a1 = -.75 * np.pi
				else:
					a0 = -.75 * np.pi
					a1 = -.25 * np.pi				
			elif '90up' in mode2:
				# If item 0 is closer to the .25pi angle than item 1
				if np.abs(self.items[0].angle-.25*np.pi) < \
					np.abs(self.items[1].angle-.25*np.pi):			
					a0 = .25 * np.pi
					a1 = .75 * np.pi
				else:
					a0 = .75 * np.pi
					a1 = .25 * np.pi				
			if steps > 0:
				x0 = self.items[0].ecc*np.cos(a0)
				y0 = self.items[0].ecc*np.sin(a0)
				x1 = self.items[1].ecc*np.cos(a1)
				y1 = self.items[1].ecc*np.sin(a1)
				traceX0 = np.linspace(self.items[0].xy[0], x0, steps)
				traceY0 = np.linspace(self.items[0].xy[1], y0, steps)
				traceX1 = np.linspace(self.items[1].xy[0], x1, steps)
				traceY1 = np.linspace(self.items[1].xy[1], y1, steps)
				for i in range(steps):
					self.items[0].setXY((traceX0[i], traceY0[i]))
					self.items[1].setXY((traceX1[i], traceY1[i]))
					self.show()
			self.items[0].setAngle(a0)
			self.items[1].setAngle(a1)				
			if 'mirror' in mode2:
				self.items[0].showMirror = True
				self.items[1].showMirror = True
				
		def selectionLoop(self, initialSleep=1000, invertSteps=1500, adaptDur=500,
			collectDur=250, target=None, mode2='180', likelihoodThr=2,
			cue=None):
			
			"""
			desc:
				Starts the selection loop, which ends when only one item is left.
				
			keywords:
				initialSleep:	The initial sleep duration.
				invertStep:		The number of franes for the invert animation.
				adaptDur:		The duration of the adaptation period.
				collectDur:		The duration of the pupil-size-collection period.
				target:			The target to be selected.
				mode2:			Indicates the mode of the final selection round, in
								which only two items are left. Should be '180',
								'90up', '90down', '90upmirror', or '90downmirror'.
				likelihoodThr:	The likelihood-ratio threshold. If 2, this means
								that items are pruned when their likelihood is less
								than 2 times the mean likelihood.
				cue:			Indicates the item that should be cued, or None to
								cue no items.
				
			returns:
				An (item, rounds) tuple containing the winning item and the number
				of rounds that the selection loop took.
			"""
			
			self.setMode2(mode2, steps=0)
			eyetracker.log('start_selection_loop')
			eyetracker.log('var target %s' % target)		
			eyetracker.log('var mode2 %s' % mode2)
			eyetracker.log('var stabilize %s' % self.stabilize)
			for item in self.items:
				item.log(status='init')		
			rounds = 0
			self.show(background=False, cue=cue)
			exp.sleep(initialSleep)
			self.show()
			collectPupilTrace(self, initialSleep)
			idx = -1
			count = 0
			while True:
				while idx == -1:
					print("count", count)
					idx = self.invert(dur=invertSteps)
					count = count + 1
					print("idx",idx)
				return idx
	__end__
	set _prepare ""

define keyboard_response keyboard_response
	set timeout infinite
	set flush yes
	set event_type keypress
	set duration keypress
	set description "Collects keyboard responses"
	set allowed_responses q

define logger logger
	set description "Logs experimental data"
	set auto_log yes

define logger logger_1
	set description "Logs experimental data"
	set auto_log yes

define logger logger_3
	set description "Logs experimental data"
	set auto_log yes

define inline_script new_inline_script
	set description "Executes Python code"
	___run__
	dur = 2500
	colours = ['black','white']
	for x in range(2):
		items = {
				colours[x-1]		: colours[x-1],
				}
		itemKeys = [
				colours[x-1]
				,]
	
		if self.get('stabilize') != 'no':
			stabilize = True
		else:
			stabilize = False		
		if self.get('checkFix') != 'no':
			checkFix = True
		else:
			checkFix = False
		ia = ItemArray(itemKeys,
			ecc=self.get('ecc'),
			size=self.get('size'),
			bgScale= var.bgScale,
			stabilize=stabilize,
			writingIndicator=None,
			check=checkFix
			)
		if colours[x] == 'white':
			colour = 1
		else:
			colour = -1
		ia.invertCalibration(dur, colour)
	__end__
	set _prepare ""

define inline_script new_inline_script_1
	set description "Executes Python code"
	___run__
	print(self.get('counter'))
	counter1='1'
	print('The current row:')
	
	#print(items['loop1'].live_dm[var.rowNumber])
	print(var.rowNumber)
	if (var.rowNumber==5):
		sys.exit()
	__end__
	___prepare__
	myCanvas = canvas()
	myCanvas.fixdot()
	
	myCanvas['up_left'] = Circle(-250, -250  , 130, fill=True, color=var.colorUp)
	myCanvas['down_right'] = Circle(250, 250, 130, fill=True, color=var.colorDown)
	myCanvas['down_left'] = Circle(-250, 250, 130, fill=True, color=var.colorLeft)
	myCanvas['up_right'] = Circle(250, -250, 130, fill=True, color=var.colorRight)
	myCanvas.show()
	clock.sleep(5000)
	
	var.counter = u'var.counter'
	
	myCanvas.clear()
	__end__

define loop new_loop
	set source_file ""
	set source table
	set repeat 1
	set order random
	set description "Repeatedly runs another item"
	set cycles 1
	set continuous no
	set break_if_on_first yes
	set break_if never
	setcycle 0 empty_column ""
	run ""

define pygaze_drift_correct new_pygaze_drift_correct
	set ypos 0
	set xpos 0
	set target_style default
	set target_color "[foreground]"
	set fixation_triggered no
	set draw_target yes
	set description "Perform eye-tracker drift correction"

define pygaze_drift_correct new_pygaze_drift_correct_1
	set ypos 0
	set xpos 0
	set target_style default
	set target_color "[foreground]"
	set fixation_triggered no
	set draw_target yes
	set description "Perform eye-tracker drift correction"

define pygaze_drift_correct new_pygaze_drift_correct_2
	set ypos 0
	set xpos 0
	set target_style default
	set target_color "[foreground]"
	set fixation_triggered no
	set draw_target yes
	set description "Perform eye-tracker drift correction"

define pygaze_start_recording new_pygaze_start_recording
	set status_msg start_trial
	set description "Puts the eye tracker into recording mode"

define pygaze_start_recording new_pygaze_start_recording_1
	set status_msg start_trial
	set description "Puts the eye tracker into recording mode"

define pygaze_drift_correct pygaze_drift_correct
	set ypos 0
	set xpos 0
	set target_style default
	set target_color "[foreground]"
	set fixation_triggered yes
	set draw_target yes
	set description "Perform eye-tracker drift correction"

define pygaze_drift_correct pygaze_drift_correct_1
	set ypos 0
	set xpos 0
	set target_style default
	set target_color "[foreground]"
	set fixation_triggered no
	set draw_target yes
	set description "Perform eye-tracker drift correction"

define pygaze_init pygaze_init
	set tracker_type "Advanced dummy (mouse simulation)"
	set tobiiglasses_udpport 49152
	set tobiiglasses_address "192.168.71.50"
	set smi_send_port 4444
	set smi_recv_port 5555
	set smi_ip "127.0.0.1"
	set sacc_vel_thr 35
	set sacc_acc_thr 9500
	set eyelink_pupil_size_mode area
	set eyelink_force_drift_correct yes
	set eyelink_calbeep yes
	set description "Initialize and calibrate eye tracker"
	set calibrate yes
	set calbeep yes
	set _logfile automatic

define pygaze_log pygaze_log
	set throttle 2
	set msg ""
	set description "Writes information to the eye-tracker logfile"
	set auto_log yes

define pygaze_log pygaze_log_1
	set throttle 2
	set msg ""
	set description "Writes information to the eye-tracker logfile"
	set auto_log no

define pygaze_start_recording pygaze_start_recording
	set status_msg "start_trial [count_exp_sequence]"
	set description "Puts the eye tracker into recording mode"

define pygaze_start_recording pygaze_start_recording_1
	set status_msg "start_trial[count_calibration_sequence]"
	set description "Puts the eye tracker into recording mode"

define pygaze_start_recording pygaze_start_recording_2
	set status_msg "start_trial [count_calibration_sequence]"
	set description "Puts the eye tracker into recording mode"

define pygaze_stop_recording pygaze_stop_recording
	set status_msg stop_trial
	set description "Stops recording of eye tracking data"

define pygaze_stop_recording pygaze_stop_recording_1
	set status_msg stop_trial
	set description "Stops recording of eye tracking data"

define sequence python_definitions
	set flush_keyboard yes
	set description "Runs a number of items in sequence"
	run default_settings always
	run globals always
	run speech always
	run smoothing always
	run item always
	run itemArray always
	run eye_tracker always
	run get_input always

define inline_script select_target
	set description "Executes Python code"
	___run__
	if var.showCue == 'yes':
		cue = var.target
	else:
		cue = None
	if var.stabilize != 'no':
		stabilize = True
	else:
		stabilize = False
	if var.checkFix != 'no':
		checkFix = True
	else:
		checkFix = False
	ia = ItemArray(list(var.itemIds),
		ecc=var.ecc,
		size=var.size,
		stabilize=stabilize,
		check=checkFix
		)
	items = ia.items[:]
	t0 = clock.time()
	winner = ia.selectionLoop(
		target=var.target,
		mode2=var.mode2,
		likelihoodThr=var.likelihoodThr,
		cue=cue
		)
	t1 = clock.time()
	rt = .001 * (t1-t0)
	var.winner = winner
	var.loop_rt = rt
	print(var.words[var.winner])
	clock.sleep(2)
	__end__
	set _prepare ""

define sketchpad sketchpad
	set reset_variables no
	set duration keypress
	set description "Displays stimuli"
	draw textline center=1 color=green font_bold=no font_family=mono font_italic=no font_size=32 html=yes show_if=always text=Select x=0 y=-288 z_index=0
	draw textline center=1 color=green font_bold=no font_family=mono font_italic=no font_size=32 html=yes show_if=always text="Press a key to continue" x=0 y=320 z_index=0
	draw image center=1 file="[target].png" scale=1 show_if=always x=0 y=0 z_index=0

define inline_script smoothing
	set description "Executes Python code"
	___run__
	import numpy
	
	def smooth(x, window_len=11, window='hanning'):
		"""
		desc:
			Smooths an array using a window with requested size and shape.
			
		source:
			<http://wiki.scipy.org/Cookbook/SignalSmooth>
		
		arguments:
			x:				The input array.
			
		keywords:
			window_len: 	The length of the window. Should be an odd integer.
			window:			The type of window from 'flat', 'hanning', 'hamming',
							'bartlett', 'blackman'.
	
		returns:
			A smoothed array.		
		"""
	
		if x.ndim != 1:
			raise ValueError, "smooth only accepts 1 dimension arrays."
		if x.size < window_len:
			raise ValueError, "Input vector needs to be bigger than window size."
		if window_len<3:
			return x
		if not window in ['flat', 'hanning', 'hamming', 'bartlett', 'blackman']:
			raise ValueError, "Window is on of 'flat', 'hanning', 'hamming','bartlett', 'blackman'"
		s=numpy.r_[x[window_len-1:0:-1],x,x[-1:-window_len:-1]]
		if window == 'flat': #moving average
			w=numpy.ones(window_len,'d')
		else:
			w=eval('numpy.'+window+'(window_len)')
		y=numpy.convolve(w/w.sum(),s,mode='valid')
		return y
	__end__
	set _prepare ""

define inline_script speak_target
	set description "Executes Python code"
	___run__
	say(u'Select %s' % var.target)
	__end__
	set _prepare ""

define inline_script speech
	set description "Executes Python code"
	___run__
	def say(msg):
		
		"""
		desc:
			Speak a message with the espeak synthesizer (if available).
			
		arguments:
			msg:	The message to speak.
		"""
		
		try:
			subprocess.Popen(['espeak', '-s', '140', msg])
		except:
			print('Text synthesis not available!')
	__end__
	set _prepare ""

define loop two_options
	set source_file ""
	set source table
	set skip 0
	set repeat 4
	set order random
	set offset no
	set item exp_sequence
	set description "Repeatedly runs another item"
	set cycles 4
	set continuous no
	set column_order "target;itemIds"
	set break_if_on_first yes
	set break_if never
	setcycle 0 target A
	setcycle 0 itemIds AB
	setcycle 1 target A
	setcycle 1 itemIds BA
	setcycle 2 target B
	setcycle 2 itemIds AB
	setcycle 3 target B
	setcycle 3 itemIds BA
	run exp_sequence

